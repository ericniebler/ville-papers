<!DOCTYPE HTML>
<html>
<head>
	<title>Member customization points for Senders and Receivers</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
Document number: D2855R1
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
2024-02-16<br/>
</address>
<hr/>
<h1 align=center>Member customization points for Senders and Receivers</h1>

<h2>Abstract</h2>

<p>
  There have been various suggestions that Senders and Receivers need a new
  language feature for customization points, to avoid the complexity
  of ADL tag_invoke.</p>

<p>This paper makes the case that C++ already has such a language
  facility, and it works just fine for the purposes of Senders and Receivers.
</p>

<p>That language facility is member functions.</p>

<p>In a nutshell, the approach in this paper is relatively straightforward;
  for all non-query customization points, ADL tag_invoke overloads become
  member functions.
  Query customization points become query member functions that take
  the query tag as an argument.</p>

<p>This is because non-queries don't need to forward calls to customization
  points, but it's useful for queries to be able to forward queries.</p>

<p>In order to be able to write perfect-forwarding function templates
  that work both for lvalues and rvalues, we use deduced this. When
  there is no need to write a single function for both lvalues and rvalues,
  a traditional non-static member function will do.
</p>

<h2>The overall highest-priority goal of this proposal is "No ADL, <em>anywhere</em>"</h2>

</body>

<h2>Quick examples</h2>

<p>
  A tag_invoke customization point for start 
  <pre><blockquote><code>friend void tag_invoke(std::execution::start_t, recv_op&amp; self) noexcept</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote><code>void start() noexcept</code></blockquote></pre>
</p>
<p>
  A perfect-forwarding connect
<pre><blockquote></code>template &lt;__decays_to&lt;__t&gt; _Self, receiver _Receiver&gt;
    requires sender_to&lt;__copy_cvref_t&lt;_Self, _Sender&gt;, __receiver&lt;_Receiver&gt;&gt;
friend auto tag_invoke(std::execution::connect_t, _Self&amp;&amp; __self, _Receiver __rcvr)
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
<pre><blockquote></code>template &lt;__decays_to&lt;__t&gt; _Self, receiver _Receiver&gt;
    requires sender_to&lt;__copy_cvref_t&lt;_Self, _Sender&gt;, __receiver&lt;_Receiver&gt;&gt;
auto connect(this _Self&amp;&amp; __self, _Receiver __rcvr)
</code></blockquote></pre>
</p>
<p>
The call
<pre><blockquote></code>tag_invoke(std::execution::connect, std::forward&lt;Snd&gt;(s), r);
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote></code>std::forward&lt;Snd&gt;(s).connect(r);
</code></blockquote></pre>
</p>
<p>A query
  <pre><blockquote><code>friend in_place_stop_token tag_invoke(std::execution::get_stop_token_t, const __t&amp; __self) noexcept
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote><code>in_place_stop_token query(std::execution::get_stop_token_t) const noexcept
</code></blockquote></pre>
</p>

<h2>A note on what changed there from R0</h2>

<p>After an LEWG discussion where it was suggested that tag parameters/arguments are untoward, and a very helpful suggestion that if we have wrappers anyway, we can use nested types instead, various people discussing this came to the conclusion that that feedback is right - we don't need the tags, except for query. We can add member typedef opt-ins to operation states, like we already have in receivers, and then we don't need those tag parameters/arguments.
</p>
<p>
  Furthermore, we don't need to name the query function a "tag_query". It's a query, it takes a tag, but that tag-taking doesn't need to go into the name.
  It's a member function. If you manage to mix such functions in a wrapper class, don't do it. Don't multi-inherit things into your sender wrapper, don't multi-inherit a sender wrapper and something else. Or if you do, use whatever
  usual techniques to disambiguate declarations and calls, but mostly
  just don't do it.
</p>
<h2>What does this buy us?</h2>

<p>
  First of all, two things, both rather major:
  <ol>
    <li>NO ADL.</li>
    <li>..and that makes defining customization points *much* simpler.</li>
  </ol>
</p>

<p>
  A bit of elaboration on the second point: consider that earlier query
  of get_stop_token in tag_invoke form. It's an example of that query
  for the when_all algorithm. But what needs to be done is that
  both that query (which is a hidden friend) and the when_all_t
  function object type are in a detail-namespace,
  and then outside that namespace, in namespace std::execution, the
  type is brought into scope with a using-declaration, and the actual
  function object is defined.
</p>
<p>Roughly like this:
  <pre><blockquote><code>namespace you_will_have_trouble_coming_up_with_a_name_for_it {
  template &lt;class Snd, class Recv, class Fn&gt;
  struct my_then_operation {
    opstate op;
    struct t {
      friend void tag_invoke(start_t, t& self) noexcept {
        start(self.op_);
      }
    };
  };
  // ADL-protected internal senders and receivers omitted
  struct my_then_t {
    template &lt;sender Snd, class Fn&gt; // proper constraints omitted
    sender auto operator(Snd&& sndr, Fn&& fn) {
      // the actual implementation omitted
    }
  };
}
using you_will_have_trouble_coming_up_with_a_name_for_it::my_then_t;
constexpr my_then_t my_then{};
</code></pre></blockquote>
</p>
<p>
  This has the effect of keeping the overload set small, when each
  and every type and its customizations are meticulously defined
  that way. Build times are decent, the sizes of overload sets are nicely
  controlled and are small, diagnostics for incorrect calls are hopefully
  fairly okay.
</p>
<p>
  But that's not all there is to it. Generic code that uses such things
  should wrap its template parameters into utilities that prevent ADL
  via template parameters. You might see something like this gem:
  <pre><blockquote><code>// For hiding a template type parameter from ADL
template &lt;class _Ty&gt;
struct _X {
  using __t = struct _T {
    using __t = _Ty;
  };
};
template &lt;class _Ty&gt;
using __x = __t&lt;_X&lt;_Ty&gt;&gt;;
</code></blockquote></pre>
</p>
<p>
  and then use it like this:
  <pre><blockquote><code>using make_stream_env_t = stream_env&lt;stdexec::__x&lt;BaseEnv&gt;&gt;;
  </code></blockquote></pre>
</p>
<p>With member customization points, you don't need any such acrobatics.
  The customization points are members. You define a customization point
  as a member function, and you can just put your type directly into
  whichever namespace you want (some might even use the global namespace),
  and you don't need to use nested detail namespaces. Then you
  call <code>foo.connect(std::execution::connect, receiver);</code> and you
  don't have to do the no-ADL wrapping in your template parameters either.
</p>
<p>
  In other words, the benefits of avoiding ADL for the implementation include
  <ul>
    <li>no need to wrap template parameters, to avoid making their associated namespaces be considered for ADL</li>
    <li>no need to wrap a sender algorithm's internal operation states, senders, and receivers into nested namespaces, to limit the searched scopes when ADL would be applied on such a type</li>
    <li>no need to wrap a sender algorithm into a nested namespaces and do a using-declaration in an outer one, again to limit the seached scopes when ADL would be applied on something else, wishing to avoid finding the functions in the namespace of the algorithm.</li>
  </ul>
  Some of those are fairly traditional ADL-taming techniques, some may be recent realizations. None of them are necessary when members are used, none. This should greatly simplify the implementation. The benefits for the users are mostly
  the same, they don't need to apply any of those techniques, not for their
  custom schedulers, not for their custom senders, not for their
  algorithm customizations, not for anything.
</p>
  
</p>
<p>The definition of customization points is much simpler, to a ridiculous
  extent. Using them is simpler; it's a member call, everybody knows
  what that does, and many people know what scopes that looks in, and
  a decent amount of people appreciate the many scopes it *doesn't* look in.</p>
<p>Composition and reuse and wrapping of customization points becomes much
  easier, because it's just.. ..good old OOP, if you want to look at it that
  way. We're not introducing a new language facility for which you need
  to figure out how to express various function compositions and such,
  the techniques and patterns are decades old, and work here as they always
  worked.</p>

<h2>What are its downsides compared to a new language facility?</h2>

<p>Well, we don't do anything for users who for some reason _have_ to
  use ADL customization points. But the reason for going for this approach
  is that we decouple Senders and Receivers from an unknown quantity,
  and avoid many or even most of the problems of using ADL customization points.
</p>
<p>Other than that, I'm not sure such downsides exist.</p>

<p>A common concern with using wrappers is that they don't work
  if you have existing APIs that use the wrappees - introducing wrappers
  into such situations just doesn't work, because they simply aren't
  the same type, and can't be made the same type. And a further
  problem is having to deal with both the wrappers and wrappees
  as concrete types, and figuring out when to use which, and possibly
  having to duplicate code to deal with both.
</p>
<p>
  The saving grace with Senders and Receivers is that they are wrapped
  everywhere all the time. Algorithms wrap senders, the wrapped senders
  wrap their receivers, and resulting operation states. This wrapping
  nests pretty much infinitely.
</p>
<p>For cases where you need to use a concrete sender, it's probably
  type-erased, rather than being a use of a concrete target sender.
</p>

<h2>Implementation experience</h2>

<p>
  A very partial work-in-progress implementation exists as a branch of
  the reference implementation of P2300, at
  <a href="https://github.com/villevoutilainen/wg21_p2300_std_execution/tree/P2855_member_customization_points">https://github.com/villevoutilainen/wg21_p2300_std_execution/tree/P2855_member_customization_points</a>.
</p>
<p>
  The implementation has the beginnings of a change from ADL tag_invoke overloads to
  non-static member functions and member functions using deduced this.
  It's rather rudimentary, and very incomplete, only covering operation states
  at this point.
</p>

<h2>Some additional considerations</h2>

<h3>Access</h3>

<p>
  It's possible to make customization point members private, and have
  them usable by the framework, by befriending the entry point (e.g.
  std::execution::connect, in a member connect(std::execution::connect_t)).
  It's perhaps ostensibly rare to need to do that, considering that
  it's somewhat unlikely that a sender wrapper or an operation state
  wrapper that provides the customization point would have oodles
  of other functionality. Nevertheless, we have made that possible in the
  prototype implementation, so we could do the same in the standard.
  This seems like an improvement over the ADL customization points.
  With them, anyone can do the ADL call, the access of a hidden friend
  doesn't matter.
</p>

<h3>Interface pollution</h3>

<p>
  It's sometimes plausible that a class with a member customization
  point inherits another class that provides the same customization point,
  and it's not an override of a virtual function. In such situations,
  the traditional technique works, bring in the base customization
  point via a using-declaration, which silences possible hiding warnings
  and also create an overload set. The expectation is that the situation
  and the technique are sufficiently well-known, since it's old-skool.
</p>

<h2>Wording</h2>

<p>
  General note: the goal here is to replace tag_invokes with member
  functions, and remove all ADL-mitigating techniques;
  there are other changes I deemed necessary at least
  for this presentation: none of the CPOs are meant to be called
  unqualified after this paper's change(s). They are not customizable
  as such, in and of themselves, despite being CPOs. They are entry
  points. The entry points are called qualified (and in some cases
  have to be; you can't just call a foo.connect() on any coroutine
  result type, but you can call std::execution::connect() on it.),
  and they are customized by the mechanism depicted in
  <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2999r3.html">P2999</a>, if the thing customized is an algorithm,
  or by writing member functions, if the thing customized is not really
  a customization but rather an opt-in.
</p>
<p>
  Additionally, it might be tempting to remove the function objects
  set_value, set_error and set_stopped completely, but there are
  things that use them as generic function objects (see <em>just-sender</em> below), so that ability is left as-is.
</p>

<p>
  Due to not using ADL, 16.4.6.17 Class template-heads can be removed, as it's
  an ADL-mitigating technique that isn't necessary when member functions
  are used for everything.
</p>

<p>
  In [functional.syn], strike <em>tag-invoke</em>, tag_invocable, nothrow_tag_invocable, tag_invoke_result, and tag_invoke.</p>

<p>In [exec.get.env]/1, edit as follows:
  <blockquote><pre><ins>std::</ins>get_env is a customization point object. For some subexpression o of type O, <ins>std::</ins>get_env(o) is expression-equivalent to
<del>tag_invoke(std::get_env, </del>const_cast&lt;const O&amp;&gt;(o)<ins>.query(std::get_env</ins>) if that expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.fwd.env]/2.1, edit the expression form:
  <blockquote><pre>mandate-nothrow-call(<del>tag_invoke, std::forwarding_query, </del>q<ins>.forwarding_query()</ins>) if that expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.get.allocator]/2, edit as follows:
  <blockquote><pre>The name <ins>std::</ins>get_allocator denotes a query object. For some subexpression r, <ins>std::</ins>get_allocator(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, std::get_allocator, </del>as_const(r)<ins>.query(std::get_allocator)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.stop.token]/2, edit as follows:
  <blockquote><pre>The name <ins>std::</ins>get_stop_token denotes a query object. For some subexpression r, <ins>std::</ins>get_stop_token(r) is expression-equivalent to:
mandate-nothrow-call(<del>tag_invoke, std::get_stop_token, </del>as_const(r)<ins>.query(std::get_stop_token)</ins>), if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.get.scheduler]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_scheduler denotes a query object. For some subexpression r, <ins>execution::</ins>get_scheduler(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, get_scheduler, </del>as_const(r)<ins>.query(execution::get_scheduler)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.scheduler]/4, edit as follows:
  <blockquote><pre><ins>execution::</ins>get_scheduler() (with no arguments) is expression-equivalent to execution::read(<ins>execution::</ins>get_scheduler)
</pre></blockquote>        
</p>

<p>In [exec.get.delegatee.scheduler]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_delegatee_scheduler denotes a query object. For some subexpression r, <ins>execution::</ins>get_delegatee_scheduler(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, get_delegatee_scheduler, </del>as_const(r)<ins>.query(execution::get_delegatee_scheduler)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.forward.progress.guarantee]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_forward_progress_guarantee denotes a query object. For some subexpression s, let S be decltype((s)).
If S does not satisfy scheduler, get_forward_progress_guarantee is ill-formed.
Otherwise, <ins>execution::</ins>get_forward_progress_guarantee(s) is expression-equivalent to:

    mandate-nothrow-call(<del>tag_invoke, get_forward_progress_guarantee, </del>as_const(s)<ins>.query(execution::get_forward_progress_guarantee)</ins>), if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.execute.may.block.caller]/2.1, edit the expression form:
  <blockquote><pre>mandate-nothrow-call(<del>tag_invoke, this_thread::execute_may_block_caller, </del>as_const(s).query(this_thread::execute_may_block_caller)</ins>), if this expression is well-formed.

</pre></blockquote>        
</p>

<p>In [exec.completion.scheduler]]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_completion_scheduler denotes a query object template. For some subexpression q, let Q be decltype((q)).
If the template argument Tag in get_completion_scheduler<Tag>(q) is not one of set_value_t, set_error_t, or set_stopped_t,
get_completion_scheduler<Tag>(q) is ill-formed. Otherwise, <ins>execution::</ins>get_completion_scheduler<Tag>(q) is expression-equivalent to
mandate-nothrow-call<del>(tag_invoke, get_completion_scheduler, </del>as_const(q)<ins>.query(execution::get_completion_scheduler)</ins>) if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.sched]/1, edit as follows:
  <blockquote><pre><ins>template&lt;class S&gt;
  inline constexpr bool <em>enable-scheduler</em> = // exposition only
    requires {
      typename S::is_scheduler;
    };</ins>
      
template&lt;class S&lt;
  concept scheduler =
    <ins><em>enable-scheduler</em>&lt;remove_cvref_t&lt;S&gt;&gt; &&</ins>      
    queryable&lt;S&gt; &&
    requires(S&& s, const get_completion_scheduler_t&lt;set_value_t&gt; tag) {
      { schedule(std::forward&lt;S&gt;(s)) } -> sender;
      { <del>tag_invoke(tag, std::get_env(</del>
          <ins>std::execution::</ins>schedule(std::forward&lt;S&gt;(s))<ins>.query(std::get_env).query(tag)</ins><del>))</del> } -> same_as&lt;remove_cvref_t&lt;S&gt;&gt;;
    } &&
    equality_comparable&lt;remove_cvref_t&lt;S&gt;&gt; &&
    copy_constructible&lt;remove_cvref_t&lt;S&gt;&gt;;
</pre></blockquote>        
</p>

<p>In [exec.recv.concepts]/1, edit as follows:
  <blockquote><pre>template<class R>
  inline constexpr bool <del>enable_receiver</del><ins><em>enable-receiver</em> = // exposition only</em></ins>
    requires {
      typename R::is_receiver;
    };

template<class R>
  concept receiver =
    <del>enable_receiver</del><ins><em>enable-receiver</em>&lt;remove_cvref_t&lt;R&gt;&gt;</ins> &&
    requires(const remove_cvref_t<R>& r) {
      { <ins>std::</ins>get_env(r) } -> queryable;
    } &&
    move_constructible&lt;remove_cvref_t&lt;R&gt;&gt; &&  // rvalues are movable, and
    constructible_from&lt;remove_cvref_t&lt;R&gt;, R&gt;; // lvalues are copyable
</pre></blockquote>        
</p>

<p>Strike [exec.recv.concepts]/2:

  <blockquote><pre><del>Remarks: Pursuant to [namespace.std], users can specialize enable_receiver to true for cv-unqualified program-defined types
that model receiver, and false for types that do not. Such specializations shall be usable in constant expressions ([expr.const]) and have type const bool.</del>
</pre></blockquote>        
</p>

<p>In [exec.set.value]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_value is a value completion function ([async.ops]). Its associated completion tag is <ins>execution::</ins>set_value_t.
The expression <ins>execution::</ins>set_value(R, Vs...) for some subexpression R and pack of subexpressions Vs is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_value, </del>R<ins>.set_value<del,</del>(Vs...)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.set.error]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_error is an error completion function. Its associated completion tag is <ins>execution::</ins>set_error_t.
The expression <ins>execution::</ins>set_error(R, E) for some subexpressions R and E is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_error, R, E)</del>R.set_error(E)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.set.stopped]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_stopped is a stopped completion function. Its associated completion tag is <ins>execution::</ins>set_stopped_t.
The expression <ins>execution::</ins>set_stopped(R) for some subexpression R is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_stopped, R</del><ins>R.set_stopped()</ins>).
</pre></blockquote>        
</p>

<p>In [exec.opstate]/1, edit as follows:
  <blockquote><pre><ins>inline constexpr bool <em>enable-operation-state</em> = // exposition only
    requires {
      typename S::is_operation_state;
    };</ins>

template<class O>
  concept operation_state =
    <ins><em>enable-operation-state</em>&lt;O&gt; &&</ins>
    queryable&lt;O&gt; &&
    is_object_v&lt;O&gt; &&
    requires (O& o) {
      { <ins>std::execution::</ins>start(o) } noexcept;
    };
</pre></blockquote>        
</p>

<p>In [exec.snd.concepts]/1, edit as follows:
  <blockquote><pre>template&lt;class S&gt;
  inline constexpr bool <del>enable_sender</del><ins><em>enable_sender</em></ins> = <ins>// exposition only </ins>
    requires { typename S::is_sender; };

template&lt;is-awaitable&lt;env-promise&lt;empty_env&gt;&gt; S&gt; // [exec.awaitables]
  inline constexpr bool <del>enable_sender</del><ins><em>enable-sender</em></ins>&lt;S&gt; = true;

template<class S>
  concept sender =
    <del>enable_sender</del><ins><em>enable-sender</em></ins>&lt;remove_cvref_t&lt;S&gt;&gt; &&
    requires (const remove_cvref_t&lt;S&gt;& s) {
      { <ins>std::</ins>get_env(s) } -> queryable;
    } &&
    move_constructible&lt;remove_cvref_t&lt;S&gt;&gt; &&  // rvalues are movable, and
    constructible_from&lt;remove_cvref_t&lt;S&gt;, S>; // lvalues are copyable

template<class S, class E = empty_env>
  concept sender_in =
    sender&lt;S&gt; &&
    requires (S&& s, E&& e) {
      { <ins>std::execution::</ins>get_completion_signatures(std::forward&lt;S&gt;(s), std::forward&lt;E&gt;(e)) } ->
        valid-completion-signatures;
    };

template<class S, class R>
  concept sender_to =
    sender_in&lt;S, env_of_t&lt;R&gt;&gt; &&
    receiver_of&lt;R, completion_signatures_of_t&lt;S, env_of_t&lt;R&gt;&gt;&gt; &&
    requires (S&& s, R&& r) {
      <ins>std::execution::</ins>connect(std::forward&lt;S&gt;(s), std::forward&lt;R&gt;(r));
    };
</pre></blockquote>        
</p>

<p>Strike [exec.snd.concepts]/3:

  <blockquote><pre><del>Remarks: Pursuant to [namespace.std], users can specialize enable_sender to true for cv-unqualified program-defined
types that model sender, and false for types that do not. Such specializations shall be usable in constant expressions ([expr.const]) and have type const bool.</del>
</pre></blockquote>        
</p>

<p>In [exec.snd.concepts]/6, edit as follows:

  <blockquote><pre>

Library-provided sender types:

    - Always expose an overload of a <del>customization of</del><ins>member</ins> connect that accepts an rvalue sender.

    - Only expose an overload of a <del>customization of</del><ins>member</ins> connect that accepts an lvalue sender if they model copy_constructible.

    - Model copy_constructible if they satisfy copy_constructible.
</pre></blockquote>        
</p>

<p>In [exec.awaitables]/5, edit as follows:

  <blockquote><pre>template&lt;class T&gt;
    requires <del>tag_</del>invocable&lt;as_awaitable_t, T, Derived&&gt;
      auto await_transform(T&& value)
        noexcept(nothrow_<del>tag_</del></ins>invocable&lt;as_awaitable_t, T, Derived&&gt;)
    -> <del>tag_</del>invoke_result_t&lt;as_awaitable_t, T, Derived&&gt; {
    return <del>tag_</del>invoke(as_awaitable, std::forward&lt;T&gt;(value), static_cast&lt;Derived&&gt;(*this));
  }
</pre></blockquote>        
</p>

<p>In [exec.awaitables]/6, edit as follows:

  <blockquote><pre>template&lt;class Env&gt;
struct env-promise : with-await-transform&lt;env-promise&lt;Env&gt;&gt; {
  unspecified get_return_object() noexcept;
  unspecified initial_suspend() noexcept;
  unspecified final_suspend() noexcept;
  void unhandled_exception() noexcept;
  void return_void() noexcept;
  coroutine_handle&lt;&gt; unhandled_stopped() noexcept;

  <del>friend const Env& tag_invoke(get_env_t, const env-promise&) noexcept;</del>
  <ins>const Env& query(get_env_t, const env-promise&) noexcept;</ins>
};
</pre></blockquote>        
</p>

<p>In [exec.getcomplsigs]/1, edit as follows:

  <blockquote><pre><ins>execution::</ins>get_completion_signatures is a customization point object.
Let s be an expression such that decltype((s)) is S, and let e be an expression such that decltype((e)) is E.
Then <ins>execution::</ins>get_completion_signatures(s, e) is expression-equivalent to:

    <del>tag_invoke_result_t&lt;get_completion_signatures_t, S, E&gt;{}</del><ins>s.query(std::get_completion_signatures, e) if that expression is well-formed,

        Mandates: valid-completion-signatures&lt;Sigs&gt;, where Sigs<del> names the type tag_invoke_result_t&lt;get_completion_signatures_t, S, E&gt;</del><ins>is the type of the expression</ins>.

</pre></blockquote>        
</p>

<p>In [exec.connect]/3, edit as follows:

  <blockquote><pre>Let connect-awaitable-promise be the following class:

struct connect-awaitable-promise : with-await-transform<connect-awaitable-promise> {
  DR& rcvr; // exposition only

  connect-awaitable-promise(DS&, DR& r) noexcept : rcvr(r) {}

  suspend_always initial_suspend() noexcept { return {}; }
  [[noreturn]] suspend_always final_suspend() noexcept { std::terminate(); }
  [[noreturn]] void unhandled_exception() noexcept { std::terminate(); }
  [[noreturn]] void return_void() noexcept { std::terminate(); }

  coroutine_handle<> unhandled_stopped() noexcept {
    <del>set_stopped(</del><ins>(</ins>(DR&&) rcvr<ins>).set_stopped()</ins>);
    return noop_coroutine();
  }

  operation-state-task get_return_object() noexcept {
    return operation-state-task{
      coroutine_handle&lt;connect-awaitable-promise&gt;::from_promise(*this)};
  }

  <del>friend</del> auto <del>tag_invoke</del><ins>query</ins>(get_env_t<del>, connect-awaitable-promise& self</del>)
    noexcept(nothrow-callable&lt;<ins>std::</ins>get_env_t, const DR&&gt;) -> env_of_t&lt;const DR&&gt; {
    return <ins>std::</ins>get_env(<del>self.</del>rcvr);
  }
};


</pre></blockquote>        
</p>

<p>In [exec.connect]/4, edit as follows:

  <blockquote><pre>Let operation-state-task be the following class:

struct operation-state-task {
  using promise_type = connect-awaitable-promise;
  coroutine_handle&lt;&gt; coro; // exposition only

  explicit operation-state-task(coroutine_handle&lt;&gt; h) noexcept : coro(h) {}
  operation-state-task(operation-state-task&& o) noexcept
    : coro(exchange(o.coro, {})) {}
  ~operation-state-task() { if (coro) coro.destroy(); }

  <del>friend</del> void <del>tag_invoke(start_t, </del><ins>start(</ins><del>operation-state-task& self</del>) noexcept {
    <del>self.</del>coro.resume();
  }
};


</pre></blockquote>        
</p>


<p>In [exec.connect]/6, edit as follows:

  <blockquote><pre>If S does not satisfy sender or if R does not satisfy receiver, <ins>std::execution::</ins>connect(s, r) is ill-formed. Otherwise, the expression <ins>std::execution::</ins>connect(s, r) is expression-equivalent to:

    <del>tag_invoke(connect, s, r)</del><ins>s.connect(r)</ins> <del>if connectable-with-tag-invoke<S, R> is modeled</del><ins>if that expression is well-formed</ins>.

        Mandates: The type of the <del>tag_invoke</del> expression above satisfies operation_state.

    Otherwise, <em>connect-awaitable</em>(s, r) if that expression is well-formed.

    Otherwise, <ins>std::execution::</ins>connect(s, r) is ill-formed.



  </pre></blockquote>        
</p>

<p>In [exec.schedule]/2, edit as follows:

  <blockquote><pre>The name <ins>execution::</ins>schedule denotes a customization point object. For some subexpression s, the expression <ins>execution::</ins>schedule(s) is expression-equivalent to:

<del>tag_invoke(schedule, s)</del><ins>s.schedule()</ins>, if that expression is valid. If the <del>function selected by tag_invoke does not return</del> <ins>type of the expression is not</ins>
a sender whose set_value completion scheduler is equivalent to s, the behavior of calling <ins>execution::</ins>schedule(s) is undefined.

        Mandates: The type of the <del>tag_invoke</del> expression above satisfies sender.

    Otherwise, <ins>execution::</ins>schedule(s) is ill-formed.


  </pre></blockquote>        
</p>

<p>In [exec.just]/2, edit as follows:

  <blockquote><pre>Let just-sender be the class template:

template&lt;class Tag, movable-value... Ts&gt;
struct just-sender { // exposition only
  using is_sender = unspecified;
  using completion_signatures =
    execution::completion_signatures&lt;Tag(Ts...)&gt;;

  tuple&lt;Ts...&gt; vs_; // exposition only

  template&lt;class R&gt;
  struct operation { // exposition only
    tuple&lt;Ts...&gt; vs_; // exposition only
    R r_; // exposition only

    <del>friend</del> void <del>tag_invoke(start_t, operation& s</del><ins>start(</ins>) noexcept {
      apply([this](Ts&... values) {
        Tag()(std::move(<del>s.</del>r_), std::move(values)...);
      }, <del>s.</del>vs_);
    }
  };

  template&lt;receiver_of&lt;completion_signatures&gt; R&gt;
    requires (copy_constructible&lt;Ts&gt; &&...)
  <del>friend</del> operation&lt;decay_t&lt;R&gt;&gt; <del>tag_invoke(connect_t, </del><del>const just-sender& s, </del><ins>connect(</ins>R && r) {
    return { <del>s.</del>vs_, std::forward<R>(r) };
  }

  template&lt;receiver_of&lt;completion_signatures&gt; R&gt;
  <del>friend</del> operation&lt;decay_t&lt;R&gt;&gt; <del>tag_invoke(connect_t, just-sender&& s, </del><ins>connect(</ins>R && r) {
    return { std::move(<del>s.</del>vs_), std::forward<R>(r) };
  }
};


  </pre></blockquote>        
</p>

<p>In [exec.just]/3,4,5, edit as follows:

  <blockquote><pre>The name <ins>execution::</ins>just denotes a customization point object.
For some pack of subexpressions vs, let Vs be the template paramter pack decltype((vs)).
<ins>execution::</ins>just(vs...) is expression-equivalent to just-sender&lt;set_value_t, remove_cvref_t&lt;Vs&gt;...&gt;({vs...}).

The name <ins>execution::</ins>just_error denotes a customization point object. For some subexpression err, let Err be decltype((err)).
<ins>execution::</ins>just_error(err) is expression-equivalent to just-sender&lt;set_error_t, remove_cvref_t&lt;Err&gt;&gt;({err}).

The<del>n</del> name <ins>execution::</ins>just_stopped denotes a customization point object.
<ins>execution::</ins>just_stopped() is expression-equivalent to just-sender&lt;set_stopped_t&gt;().
  </pre></blockquote>        
</p>

<p>In [exec.just]/3,4,5, edit as follows:

  <blockquote><pre>The name <ins>execution::</ins>just denotes a customization point object.
For some pack of subexpressions vs, let Vs be the template paramter pack decltype((vs)).
<ins>execution::</ins>just(vs...) is expression-equivalent to just-sender&lt;set_value_t, remove_cvref_t&lt;Vs&gt;...&gt;({vs...}).

The name <ins>execution::</ins>just_error denotes a customization point object. For some subexpression err, let Err be decltype((err)).
<ins>execution::</ins>just_error(err) is expression-equivalent to just-sender&lt;set_error_t, remove_cvref_t&lt;Err&gt;&gt;({err}).

The<del>n</del> name <ins>execution::</ins>just_stopped denotes a customization point object.
<ins>execution::</ins>just_stopped() is expression-equivalent to just-sender&lt;set_stopped_t&gt;().
  </pre></blockquote>        
</p>

<p>In [exec.transfer.just]/2, edit as follows:

  <blockquote><pre>The name <ins>execution::</ins>transfer_just denotes a customization point object.
For some subexpression s and pack of subexpressions vs, let S be decltype((s)) and let Vs be the template parameter pack decltype((vs))....
If S does not satisfy scheduler, or any type V in Vs does not satisfy movable-value, <ins>execution::</ins>transfer_just(s, vs...) is ill-formed.
Otherwise, <ins>execution::</ins>transfer_just(s, vs...) is expression-equivalent to:

<del>tag_invoke(transfer_just, s, vs...), if that expression is valid. Let as be a pack of rvalue subexpressions of types decay_t&lt;Vs&gt;...
refering to objects direct-initilized from vs.
If the function selected by tag_invoke does not return a sender whose asynchronous operations execute value completion operations
on an execution agent belonging to the execution resource associated with s, with value result datums as, the behavior of calling transfer_just(s, vs...) is undefined.

        Mandates: sender_of<R, set_value_t(decay_t<Vs>...), E>, where R is the type of the tag_invoke expression above, and E is the type of an environment.

    Otherwise, </del><ins>execution::</ins>transfer(<ins>execution::</ins>just(vs...), s).
  </pre></blockquote>        
</p>

<p>In [exec.read]/3, edit as follows:

  <blockquote><pre>read-sender is the exposition-only class template:

template&lt;class Tag&gt;
  struct read-sender { // exposition only
    using is_sender = unspecified;
    template&lt;class R&gt;
      struct operation-state { // exposition only
        R r_; // exposition only

        <del>friend</del> void <del>tag_invoke(start_t, operation-state& s</del><ins>start(</ins>) noexcept {
          TRY-SET-VALUE(std::move(<del>s.</del>r_), Tag{}(<ins>std::</ins>get_env(<del>s.</del>r_)));
        }
      };

    template&lt;receiver R&gt;
    <del>friend</del> operation-state&lt;decay_t&lt;R&gt;&gt; <del>tag_invoke(connect_t, read-sender, </del><ins>connect(</ins>R && r) {
      return { std::forward<R>(r) };
    }

    template&lt;class Env&gt;
        requires callable&lt;Tag, Env&gt;
      <del>friend</del> auto <del>tag_invoke(get_completion_signatures_t, read-sender, </del><ins>query(get_completion_signatures_t, </ins>Env)
        -> completion_signatures&lt;
          set_value_t(call-result-t&lt;Tag, Env&gt;), set_error_t(exception_ptr)>; // not defined

    template&lt;class Env&gt;
        requires nothrow-callable&lt;Tag, Env&gt;
      <del>friend</del> auto <del>tag_invoke(get_completion_signatures_t, read-sender, </del><ins>query(get_completion_signatures_t, </ins>Env)
        -> completion_signatures&lt;set_value_t(call-result-t&lt;Tag, Env&gt;)&gt;; // not defined

    <del>friend</del> empty_env <del>tag_invoke(get_env_t, const read-sender&</del>query(get_env_t</ins>) <ins>const</ins> noexcept {
      return {};
    }
  };

where TRY-SET-VALUE(r, e), for two subexpressions r and e, is equivalent to:

try {
  <ins>execution::</ins>set_value(r, e);
} catch(...) {
  <ins>execution::</ins>set_error(r, current_exception());
}

if e is potentially-throwing; or <ins>execution::</ins>set_value(r, e) otherwise.

  </pre></blockquote>        
</p>

<p>In [exec.adapt.general]3,4,5, edit as follows:

  <blockquote><pre>Unless otherwise specified, a sender adaptor is required to not begin executing any functions that would
observe or modify any of the arguments of the adaptor before the returned sender
is connected with a receiver using <ins>execution::</ins>connect, and <ins>execution::</ins>start is called on the
resulting operation state. This requirement applies to any function that
is selected by the implementation of the sender adaptor.

Unless otherwise specified, a parent sender ([async.ops]) with a single child
sender s has an associated attribute object equal to
FWD-QUERIES(<ins>std::</ins>get_env(s)) ([exec.fwd.env]).
Unless otherwise specified, a parent sender with more than one child senders
has an associated attributes object equal to empty_env{}.
These requirements apply to any function that is selected by the implementation of the sender adaptor.

Unless otherwise specified, when a parent sender is connected to a receiver r,
any receiver used to connect a child sender has an associated environment
equal to FWD-QUERIES(<ins>std::</ins>get_env(r)). This requirements applies
to any sender returned from a function that is selected by the implementation of such sender adaptor.
  </pre></blockquote>        
</p>

<p>Strike [exec.adapt.general]6:

  <blockquote><pre><del>For any sender type, receiver type, operation state type, queryable type, or coroutine promise type that is part
of the implementation of any sender adaptor in this subclause and that is
a class template, the template arguments do not contribute to the associated
entities ([basic.lookup.argdep]) of a function call where a specialization
of the class template is an associated entity.

[Example:...</del>
  </pre></blockquote>        
</p>

<p> In [exec.on]/2, edit as follows:
  <blockquote><pre>Let replace-scheduler(e, sch) be an expression denoting an object e'
such that <ins>execution::</ins>get_scheduler(e) returns a copy of sch, and
<del>tag_invoke(tag, </del><ins>tag(</ins>e', args...) is expression-equivalent to tag(e, args...)
for all arguments args... and for all tag whose type satisfies
forwarding-query and is not <ins>execution::</ins>get_scheduler_t.
  </pre></blockquote>        
</p>

<p> In [exec.on]/3, edit as follows:
  <blockquote><pre>The name on denotes a customization point object.
For some subexpressions sch and s, let Sch be decltype((sch))
and S be decltype((s)). If Sch does not satisfy scheduler,
or S does not satisfy sender, on is ill-formed.
Otherwise, the expression <ins>execution::</ins>on(sch, s)
<del>is expression-equivalent to:

  tag_invoke(on, sch, s), if that expression is valid.
  If the function selected above does not return a sender which starts s on
  an execution agent of the associated execution resource of sch when started,
  the behavior of calling on(sch, s) is undefined.

        Mandates: The type of the tag_invoke expression above satisfies sender.

  Otherwise, </del>constructs a sender s1.
  When s1 is connected with some receiver out_r, it:

    Constructs a receiver r such that:

      When <ins>execution::</ins>set_value(r) is called,
      it calls <ins>execution::</ins>connect(s, r2), where r2 is as specified
      below, which results in op_state3. It calls <ins>execution::</ins>start(op_state3).
      If any of these throws an exception, it calls <ins>execution::</inS>set_error
      on out_r, passing current_exception() as the second argument.

      <ins>execution::</ins>set_error(r, e) is expression-equivalent to <execution::</ins>set_error(out_r, e).

      <ins>execution::</ins>set_stopped(r) is expression-equivalent to <ins>execution::</ins>set_stopped(out_r).

      <ins>std::</ins>get_env(r) is expression-equivalent to <ins>std::</ins>get_env(out_r).

    Calls <ins>execution::</ins>schedule(sch), which results in s2.
    It then calls <ins>execution::</ins>connect(s2, r), resulting in op_state2.

    op_state2 is wrapped by a new operation state, op_state1,
    that is returned to the caller.

    r2 is a receiver that wraps a reference to out_r and forwards all
    completion operations to it. In addition, <ins>std::</ins>get_env(r2) returns
    replace-scheduler(e, sch).

    When <ins>execution::</ins>start is called on op_state1,
    it calls <ins>execution::</ins>start on op_state2.

    The lifetime of op_state2, once constructed, lasts until either
    op_state3 is constructed or op_state1 is destroyed, whichever comes first.
    The lifetime of op_state3, once constructed, lasts until op_state1 is destroyed.
      
  Given subexpressions s1 and e, where s1 is a sender returned from on or a
  copy of such, let S1 be decltype((s1)).
  Let E' be decltype((replace-scheduler(e, sch))).
  Then the type of <del>tag_invoke(get_completion_signatures, s1,</del><ins>s1.query(execution::get_completion_signatures, e</ins>) shall be:...
</pre></blockquote>        
</p>

<p> In [exec.transfer]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>transfer denotes a customization point object.
For some subexpressions sch and s, let Sch be decltype((sch))
and S be decltype((s)). If Sch does not satisfy scheduler,
or S does not satisfy sender, transfer is ill-formed.
Otherwise, the expression <ins>execution::</ins>transfer(s, sch) is expression-equivalent to:

    <del>tag_invoke(transfer, get_completion_scheduler&lt;set_value_t&gt;(get_env(s)), s, sch), if that expression is valid.

        Mandates: The type of the tag_invoke expression above satisfies sender.

    Otherwise, tag_invoke(transfer, s, sch), if that expression is valid.

        Mandates: The type of the tag_invoke expression above satisfies sender.

    Otherwise, </del><ins>execution::</ins>schedule_from(sch, s).
    [DRAFTING NOTE: if we need to retain the ability to customize
    a transfer algorithm with something resembling the first signature,
    this needs to be fixed later. I'm not able to copy the algorihm
    customization mechanics into this paper.]
    If the function selected above does not return a sender which is a
    result of a call to schedule_from(sch, s2), where s2 is a sender
    which sends values equivalent to those sent by s, the behavior of
    calling transfer(s, sch) is undefined.
  </pre></blockquote>        
</p>

<p> In [exec.transfer]/3, edit as follows:
  <blockquote><pre>For a sender t returned from <ins>execution::</ins>transfer(s, sch),
<ins>std::</ins>get_env(t) shall return a queryable object q such that
<ins>execution::</ins>get_completion_scheduler&lt;CPO&gt;(q) returns a copy of sch,
where CPO is either set_value_t or set_stopped_t.
The get_completion_scheduler&lt;set_error_t&gt; query is not implemented, as
the scheduler cannot be guaranteed in case an error is thrown while trying to
schedule work on the given scheduler object. For all other query objects Q
whose type satisfies forwarding-query, the expression Q(q, args...)
shall be equivalent to Q(<ins>std::</ins>get_env(s), args...).
  </pre></blockquote>        
</p>

<p> In [exec.schedule.from]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>schedule_from denotes a customization point object.
For some subexpressions sch and s, let Sch be decltype((sch))
and S be decltype((s)). If Sch does not satisfy scheduler,
or S does not satisfy sender, <ins>execution::</ins>schedule_from is ill-formed.
Otherwise, the expression <ins>execution::</ins>schedule_from(sch, s)<del> is expression-equivalent to:

     tag_invoke(schedule_from, sch, s), if that expression is valid.
     If the function selected by tag_invoke does not return a sender
     that completes on an execution agent belonging to the associated
     execution resource of sch and completing with the same async result ([async.ops])
     as s, the behavior of calling schedule_from(sch, s) is undefined.

        Mandates: The type of the tag_invoke expression above satisfies sender.

    Otherwise, </del>constructs a sender s2. When s2 is connected with some receiver out_r, it:

        Constructs a receiver r such that when a receiver completion
        operation Tag(r, args...) is called, it decay-copies args...
        into op_state (see below) as args'... and constructs a receiver r2
        such that:

            When <ins>execution::</ins>set_value(r2) is called,
            it calls <del>Tag</del><ins>execution::set_value</ins>(out_r, std::move(args')...).

            <ins>execution::</ins>set_error(r2, e) is expression-equivalent to <ins>execution::</ins>set_error(out_r, e).

            <ins>execution::</ins>set_stopped(r2) is expression-equivalent to <ins>execution::</ins>set_stopped(out_r).

          It then calls <ins>execution::</ins>schedule(sch), resulting in
          a sender s3. It then calls <ins>execution::</ins>connect(s3, r2),
          resulting in an operation state op_state3.
          It then calls <ins>execution::</ins>start(op_state3).
          If any of these throws an exception, it catches it and calls
          <ins>execution::</ins>set_error(out_r, current_exception()).
          If any of these expressions would be ill-formed, then
          Tag(r, args...) is ill-formed.

        Calls <ins>execution::</ins>connect(s, r) resulting in
        an operation state op_state2. If this expression would be ill-formed,
        <ins>execution::</ins>connect(s2, out_r) is ill-formed.

        Returns an operation state op_state that contains op_state2.
        When <ins>execution::</ins>start(op_state) is called,
        calls <ins>execution::</ins>start(op_state2).
        The lifetime of op_state3 ends when op_state is destroyed.

    Given subexpressions s2 and e, where s2 is a sender returned from
    schedule_from or a copy of such, let S2 be decltype((s2))
    and let E be decltype((e)). Then the type of
    <del>tag_invoke(get_completion_signatures, s2, </del><ins>s2.query(execution::get_completion_signatures, </ins>e) shall be:...
  </pre></blockquote>        
</p>

</body>
</html>
