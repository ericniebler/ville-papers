<!DOCTYPE HTML>
<html>
<head>
	<title>Member customization points for Senders and Receivers</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
Document number: D2855R1
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
2024-02-16<br/>
</address>
<hr/>
<h1 align=center>Member customization points for Senders and Receivers</h1>

<h2>Abstract</h2>

<p>
  There have been various suggestions that Senders and Receivers need a new
  language feature for customization points, to avoid the complexity
  of ADL tag_invoke.</p>

<p>This paper makes the case that C++ already has such a language
  facility, and it works just fine for the purposes of Senders and Receivers.
</p>

<p>That language facility is member functions.</p>

<p>In a nutshell, the approach in this paper is relatively straightforward;
  for all non-query customization points, ADL tag_invoke overloads become
  member functions.
  Query customization points become query member functions that take
  the query tag as an argument.</p>

<p>This is because non-queries don't need to forward calls to customization
  points, but it's useful for queries to be able to forward queries.</p>

<p>In order to be able to write perfect-forwarding function templates
  that work both for lvalues and rvalues, we use deduced this. When
  there is no need to write a single function for both lvalues and rvalues,
  a traditional non-static member function will do.
</p>

<h2>The overall highest-priority goal of this proposal is "No ADL, <em>anywhere</em>"</h2>

</body>

<h2>Quick examples</h2>

<p>
  A tag_invoke customization point for start 
  <pre><blockquote><code>friend void tag_invoke(std::execution::start_t, recv_op&amp; self) noexcept</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote><code>void start() noexcept</code></blockquote></pre>
</p>
<p>
  A perfect-forwarding connect
<pre><blockquote></code>template &lt;__decays_to&lt;__t&gt; _Self, receiver _Receiver&gt;
    requires sender_to&lt;__copy_cvref_t&lt;_Self, _Sender&gt;, __receiver&lt;_Receiver&gt;&gt;
friend auto tag_invoke(std::execution::connect_t, _Self&amp;&amp; __self, _Receiver __rcvr)
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
<pre><blockquote></code>template &lt;__decays_to&lt;__t&gt; _Self, receiver _Receiver&gt;
    requires sender_to&lt;__copy_cvref_t&lt;_Self, _Sender&gt;, __receiver&lt;_Receiver&gt;&gt;
auto connect(this _Self&amp;&amp; __self, _Receiver __rcvr)
</code></blockquote></pre>
</p>
<p>
The call
<pre><blockquote></code>tag_invoke(std::execution::connect, std::forward&lt;Snd&gt;(s), r);
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote></code>std::forward&lt;Snd&gt;(s).connect(r);
</code></blockquote></pre>
</p>
<p>A query
  <pre><blockquote><code>friend in_place_stop_token tag_invoke(std::execution::get_stop_token_t, const __t&amp; __self) noexcept
</code></blockquote></pre>
</p>
<p>
  becomes
</p>
<p>
  <pre><blockquote><code>in_place_stop_token query(std::execution::get_stop_token_t) const noexcept
</code></blockquote></pre>
</p>

<h2>A note on what changed there from R0</h2>

<p>After an LEWG discussion where it was suggested that tag parameters/arguments are untoward, and a very helpful suggestion that if we have wrappers anyway, we can use nested types instead, various people discussing this came to the conclusion that that feedback is right - we don't need the tags, except for query. We can add member typedef opt-ins to operation states, like we already have in receivers, and then we don't need those tag parameters/arguments.
</p>
<p>
  Furthermore, we don't need to name the query function a "tag_query". It's a query, it takes a tag, but that tag-taking doesn't need to go into the name.
  It's a member function. If you manage to mix such functions in a wrapper class, don't do it. Don't multi-inherit things into your sender wrapper, don't multi-inherit a sender wrapper and something else. Or if you do, use whatever
  usual techniques to disambiguate declarations and calls, but mostly
  just don't do it.
</p>
<h2>What does this buy us?</h2>

<p>
  First of all, two things, both rather major:
  <ol>
    <li>NO ADL.</li>
    <li>..and that makes defining customization points *much* simpler.</li>
  </ol>
</p>

<p>
  A bit of elaboration on the second point: consider that earlier query
  of get_stop_token in tag_invoke form. It's an example of that query
  for the when_all algorithm. But what needs to be done is that
  both that query (which is a hidden friend) and the when_all_t
  function object type are in a detail-namespace,
  and then outside that namespace, in namespace std::execution, the
  type is brought into scope with a using-declaration, and the actual
  function object is defined.
</p>
<p>Roughly like this:
  <pre><blockquote><code>namespace you_will_have_trouble_coming_up_with_a_name_for_it {
  template &lt;class Snd, class Recv, class Fn&gt;
  struct my_then_operation {
    opstate op;
    struct t {
      friend void tag_invoke(start_t, t& self) noexcept {
        start(self.op_);
      }
    };
  };
  // ADL-protected internal senders and receivers omitted
  struct my_then_t {
    template &lt;sender Snd, class Fn&gt; // proper constraints omitted
    sender auto operator(Snd&& sndr, Fn&& fn) {
      // the actual implementation omitted
    }
  };
}
using you_will_have_trouble_coming_up_with_a_name_for_it::my_then_t;
constexpr my_then_t my_then{};
</code></pre></blockquote>
</p>
<p>
  This has the effect of keeping the overload set small, when each
  and every type and its customizations are meticulously defined
  that way. Build times are decent, the sizes of overload sets are nicely
  controlled and are small, diagnostics for incorrect calls are hopefully
  fairly okay.
</p>
<p>
  But that's not all there is to it. Generic code that uses such things
  should wrap its template parameters into utilities that prevent ADL
  via template parameters. You might see something like this gem:
  <pre><blockquote><code>// For hiding a template type parameter from ADL
template &lt;class _Ty&gt;
struct _X {
  using __t = struct _T {
    using __t = _Ty;
  };
};
template &lt;class _Ty&gt;
using __x = __t&lt;_X&lt;_Ty&gt;&gt;;
</code></blockquote></pre>
</p>
<p>
  and then use it like this:
  <pre><blockquote><code>using make_stream_env_t = stream_env&lt;stdexec::__x&lt;BaseEnv&gt;&gt;;
  </code></blockquote></pre>
</p>
<p>With member customization points, you don't need any such acrobatics.
  The customization points are members. You define a customization point
  as a member function, and you can just put your type directly into
  whichever namespace you want (some might even use the global namespace),
  and you don't need to use nested detail namespaces. Then you
  call <code>foo.connect(std::execution::connect, receiver);</code> and you
  don't have to do the no-ADL wrapping in your template parameters either.
</p>
<p>
  In other words, the benefits of avoiding ADL for the implementation include
  <ul>
    <li>no need to wrap template parameters, to avoid making their associated namespaces be considered for ADL</li>
    <li>no need to wrap a sender algorithm's internal operation states, senders, and receivers into nested namespaces, to limit the searched scopes when ADL would be applied on such a type</li>
    <li>no need to wrap a sender algorithm into a nested namespaces and do a using-declaration in an outer one, again to limit the seached scopes when ADL would be applied on something else, wishing to avoid finding the functions in the namespace of the algorithm.</li>
  </ul>
  Some of those are fairly traditional ADL-taming techniques, some may be recent realizations. None of them are necessary when members are used, none. This should greatly simplify the implementation. The benefits for the users are mostly
  the same, they don't need to apply any of those techniques, not for their
  custom schedulers, not for their custom senders, not for their
  algorithm customizations, not for anything.
</p>
  
</p>
<p>The definition of customization points is much simpler, to a ridiculous
  extent. Using them is simpler; it's a member call, everybody knows
  what that does, and many people know what scopes that looks in, and
  a decent amount of people appreciate the many scopes it *doesn't* look in.</p>
<p>Composition and reuse and wrapping of customization points becomes much
  easier, because it's just.. ..good old OOP, if you want to look at it that
  way. We're not introducing a new language facility for which you need
  to figure out how to express various function compositions and such,
  the techniques and patterns are decades old, and work here as they always
  worked.</p>

<h2>What are its downsides compared to a new language facility?</h2>

<p>Well, we don't do anything for users who for some reason _have_ to
  use ADL customization points. But the reason for going for this approach
  is that we decouple Senders and Receivers from an unknown quantity,
  and avoid many or even most of the problems of using ADL customization points.
</p>
<p>Other than that, I'm not sure such downsides exist.</p>

<p>A common concern with using wrappers is that they don't work
  if you have existing APIs that use the wrappees - introducing wrappers
  into such situations just doesn't work, because they simply aren't
  the same type, and can't be made the same type. And a further
  problem is having to deal with both the wrappers and wrappees
  as concrete types, and figuring out when to use which, and possibly
  having to duplicate code to deal with both.
</p>
<p>
  The saving grace with Senders and Receivers is that they are wrapped
  everywhere all the time. Algorithms wrap senders, the wrapped senders
  wrap their receivers, and resulting operation states. This wrapping
  nests pretty much infinitely.
</p>
<p>For cases where you need to use a concrete sender, it's probably
  type-erased, rather than being a use of a concrete target sender.
</p>

<h2>Implementation experience</h2>

<p>
  A very partial work-in-progress implementation exists as a branch of
  the reference implementation of P2300, at
  <a href="https://github.com/villevoutilainen/wg21_p2300_std_execution/tree/P2855_member_customization_points">https://github.com/villevoutilainen/wg21_p2300_std_execution/tree/P2855_member_customization_points</a>.
</p>
<p>
  The implementation has the beginnings of a change from ADL tag_invoke overloads to
  non-static member functions and member functions using deduced this.
  It's rather rudimentary, and very incomplete, only covering operation states
  at this point.
</p>

<h2>Some additional considerations</h2>

<h3>Access</h3>

<p>
  It's possible to make customization point members private, and have
  them usable by the framework, by befriending the entry point (e.g.
  std::execution::connect, in a member connect(std::execution::connect_t)).
  It's perhaps ostensibly rare to need to do that, considering that
  it's somewhat unlikely that a sender wrapper or an operation state
  wrapper that provides the customization point would have oodles
  of other functionality. Nevertheless, we have made that possible in the
  prototype implementation, so we could do the same in the standard.
  This seems like an improvement over the ADL customization points.
  With them, anyone can do the ADL call, the access of a hidden friend
  doesn't matter.
</p>

<h3>Interface pollution</h3>

<p>
  It's sometimes plausible that a class with a member customization
  point inherits another class that provides the same customization point,
  and it's not an override of a virtual function. In such situations,
  the traditional technique works, bring in the base customization
  point via a using-declaration, which silences possible hiding warnings
  and also create an overload set. The expectation is that the situation
  and the technique are sufficiently well-known, since it's old-skool.
</p>

<h2>Wording</h2>

<p>
  Due to not using ADL, 16.4.6.17 Class template-heads can be removed, as it's
  an ADL-mitigating technique that isn't necessary when member functions
  are used for everything.
</p>

<p>
  In [functional.syn], strike <em>tag-invoke</em>, tag_invocable, nothrow_tag_invocable, tag_invoke_result, and tag_invoke.</p>

<p>In [exec.get.env]/1, edit as follows:
  <blockquote><pre><ins>std::</ins>get_env is a customization point object. For some subexpression o of type O, <ins>std::</ins>get_env(o) is expression-equivalent to
<del>tag_invoke(std::get_env, </del>const_cast&lt;const O&amp;&gt;(o)<ins>.query(std::get_env</ins>) if that expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.fwd.env]/2.1, edit the expression form:
  <blockquote><pre>mandate-nothrow-call(<del>tag_invoke, std::forwarding_query, </del>q<ins>.forwarding_query()</ins>) if that expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.get.allocator]/2, edit as follows:
  <blockquote><pre>The name <ins>std::</ins>get_allocator denotes a query object. For some subexpression r, <ins>std::</ins>get_allocator(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, std::get_allocator, </del>as_const(r)<ins>.query(std::get_allocator)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.stop.token]/2, edit as follows:
  <blockquote><pre>The name <ins>std::</ins>get_stop_token denotes a query object. For some subexpression r, <ins>std::</ins>get_stop_token(r) is expression-equivalent to:
mandate-nothrow-call(<del>tag_invoke, std::get_stop_token, </del>as_const(r)<ins>.query(std::get_stop_token)</ins>), if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.get.scheduler]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_scheduler denotes a query object. For some subexpression r, <ins>execution::</ins>get_scheduler(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, get_scheduler, </del>as_const(r)<ins>.query(execution::get_scheduler)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.scheduler]/4, edit as follows:
  <blockquote><pre><ins>execution::</ins>get_scheduler() (with no arguments) is expression-equivalent to execution::read(<ins>execution::</ins>get_scheduler)
</pre></blockquote>        
</p>

<p>In [exec.get.delegatee.scheduler]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_delegatee_scheduler denotes a query object. For some subexpression r, <ins>execution::</ins>get_delegatee_scheduler(r) is expression-equivalent to
mandate-nothrow-call(<del>tag_invoke, get_delegatee_scheduler, </del>as_const(r)<ins>.query(execution::get_delegatee_scheduler)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.get.forward.progress.guarantee]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_forward_progress_guarantee denotes a query object. For some subexpression s, let S be decltype((s)).
If S does not satisfy scheduler, get_forward_progress_guarantee is ill-formed.
Otherwise, <ins>execution::</ins>get_forward_progress_guarantee(s) is expression-equivalent to:

    mandate-nothrow-call(<del>tag_invoke, get_forward_progress_guarantee, </del>as_const(s)<ins>.query(execution::get_forward_progress_guarantee)</ins>), if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.execute.may.block.caller]/2.1, edit the expression form:
  <blockquote><pre>mandate-nothrow-call(<del>tag_invoke, this_thread::execute_may_block_caller, </del>as_const(s).query(this_thread::execute_may_block_caller)</ins>), if this expression is well-formed.

</pre></blockquote>        
</p>

<p>In [exec.completion.scheduler]]/2, edit as follows:
  <blockquote><pre>The name <ins>execution::</ins>get_completion_scheduler denotes a query object template. For some subexpression q, let Q be decltype((q)).
If the template argument Tag in get_completion_scheduler<Tag>(q) is not one of set_value_t, set_error_t, or set_stopped_t,
get_completion_scheduler<Tag>(q) is ill-formed. Otherwise, <ins>execution::</ins>get_completion_scheduler<Tag>(q) is expression-equivalent to
mandate-nothrow-call<del>(tag_invoke, get_completion_scheduler, </del>as_const(q)<ins>.query(execution::get_completion_scheduler)</ins>) if this expression is well-formed.
</pre></blockquote>        
</p>

<p>In [exec.sched]/1, edit as follows:
  <blockquote><pre><ins>template&lt;class S&gt;
  inline constexpr bool <em>enable-scheduler</em> = // exposition only
    requires {
      typename S::is_scheduler;
    };</ins>
      
template&lt;class S&lt;
  concept scheduler =
    <ins><em>enable-scheduler</em>&lt;remove_cvref_t&lt;S&gt;&gt; &&</ins>      
    queryable&lt;S&gt; &&
    requires(S&& s, const get_completion_scheduler_t&lt;set_value_t&gt; tag) {
      { schedule(std::forward&lt;S&gt;(s)) } -> sender;
      { <del>tag_invoke(tag, std::get_env(</del>
          <ins>std::execution::</ins>schedule(std::forward&lt;S&gt;(s))<ins>.query(std::get_env).query(tag)</ins><del>))</del> } -> same_as&lt;remove_cvref_t&lt;S&gt;&gt;;
    } &&
    equality_comparable&lt;remove_cvref_t&lt;S&gt;&gt; &&
    copy_constructible&lt;remove_cvref_t&lt;S&gt;&gt;;
</pre></blockquote>        
</p>

<p>In [exec.recv.concepts]/1, edit as follows:
  <blockquote><pre>template<class R>
  inline constexpr bool <del>enable_receiver</del><ins><em>enable-receiver</em> = // exposition only</em></ins>
    requires {
      typename R::is_receiver;
    };

template<class R>
  concept receiver =
    <del>enable_receiver</del><ins><em>enable-receiver</em>&lt;remove_cvref_t&lt;R&gt;&gt;</ins> &&
    requires(const remove_cvref_t<R>& r) {
      { <ins>std::</ins>get_env(r) } -> queryable;
    } &&
    move_constructible&lt;remove_cvref_t&lt;R&gt;&gt; &&  // rvalues are movable, and
    constructible_from&lt;remove_cvref_t&lt;R&gt;, R&gt;; // lvalues are copyable
</pre></blockquote>        
</p>

<p>Strike [exec.recv.concepts]/2:

  <blockquote><pre><del>Remarks: Pursuant to [namespace.std], users can specialize enable_receiver to true for cv-unqualified program-defined types
that model receiver, and false for types that do not. Such specializations shall be usable in constant expressions ([expr.const]) and have type const bool.</del>
</pre></blockquote>        
</p>

<p>In [exec.set.value]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_value is a value completion function ([async.ops]). Its associated completion tag is <ins>execution::</ins>set_value_t.
The expression <ins>execution::</ins>set_value(R, Vs...) for some subexpression R and pack of subexpressions Vs is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_value, </del>R<ins>.set_value<del,</del>(Vs...)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.set.error]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_error is an error completion function. Its associated completion tag is <ins>execution::</ins>set_error_t.
The expression <ins>execution::</ins>set_error(R, E) for some subexpressions R and E is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_error, R, E)</del>R.set_error(E)</ins>).
</pre></blockquote>        
</p>

<p>In [exec.set.stopped]/1, edit as follows:
  <blockquote><pre><ins>execution::</ins>set_stopped is a stopped completion function. Its associated completion tag is <ins>execution::</ins>set_stopped_t.
The expression <ins>execution::</ins>set_stopped(R) for some subexpression R is ill-formed if R is an lvalue or a const rvalue.
Otherwise, it is expression-equivalent to mandate-nothrow-call(<del>tag_invoke, set_stopped, R</del><ins>R.set_stopped()</ins>).
</pre></blockquote>        
</p>

<p>In [exec.opstate]/1, edit as follows:
  <blockquote><pre><ins>inline constexpr bool <em>enable-operation-state</em> = // exposition only
    requires {
      typename S::is_operation_state;
    };</ins>

template<class O>
  concept operation_state =
    <ins><em>enable-operation-state</em>&lt;O&gt; &&</ins>
    queryable&lt;O&gt; &&
    is_object_v&lt;O&gt; &&
    requires (O& o) {
      { <ins>std::execution::</ins>start(o) } noexcept;
    };
</pre></blockquote>        
</p>

<p>In [exec.snd.concepts]/1, edit as follows:
  <blockquote><pre>template&lt;class S&gt;
  inline constexpr bool <del>enable_sender</del><ins><em>enable_sender</em></ins> = <ins>// exposition only </ins>
    requires { typename S::is_sender; };

template&lt;is-awaitable&lt;env-promise&lt;empty_env&gt;&gt; S&gt; // [exec.awaitables]
  inline constexpr bool <del>enable_sender</del><ins><em>enable-sender</em></ins>&lt;S&gt; = true;

template<class S>
  concept sender =
    <del>enable_sender</del><ins><em>enable-sender</em></ins>&lt;remove_cvref_t&lt;S&gt;&gt; &&
    requires (const remove_cvref_t&lt;S&gt;& s) {
      { <ins>std::</ins>get_env(s) } -> queryable;
    } &&
    move_constructible&lt;remove_cvref_t&lt;S&gt;&gt; &&  // rvalues are movable, and
    constructible_from&lt;remove_cvref_t&lt;S&gt;, S>; // lvalues are copyable

template<class S, class E = empty_env>
  concept sender_in =
    sender&lt;S&gt; &&
    requires (S&& s, E&& e) {
      { <ins>std::execution::</ins>get_completion_signatures(std::forward&lt;S&gt;(s), std::forward&lt;E&gt;(e)) } ->
        valid-completion-signatures;
    };

template<class S, class R>
  concept sender_to =
    sender_in&lt;S, env_of_t&lt;R&gt;&gt; &&
    receiver_of&lt;R, completion_signatures_of_t&lt;S, env_of_t&lt;R&gt;&gt;&gt; &&
    requires (S&& s, R&& r) {
      <ins>std::execution::</ins>connect(std::forward&lt;S&gt;(s), std::forward&lt;R&gt;(r));
    };
</pre></blockquote>        
</p>

<p>Strike [exec.snd.concepts]/3:

  <blockquote><pre><del>Remarks: Pursuant to [namespace.std], users can specialize enable_sender to true for cv-unqualified program-defined
types that model sender, and false for types that do not. Such specializations shall be usable in constant expressions ([expr.const]) and have type const bool.</del>
</pre></blockquote>        
</p>

</body>
</html>
